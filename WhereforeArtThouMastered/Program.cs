using System.Reflection;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;

namespace WhereforeArtThouMastered
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "WhereforeArtThouMastered.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (Settings.Value.TargetMod == null)
            {
                Console.WriteLine("Wherefore didst the user not tell me the target mod?");
                return;
            }

            if (Settings.Value.CandidateMaster == null)
            {
                Console.WriteLine("Wherefore didst the user not tell me the candidate master?");
                return;
            }

            var targetModKey = Settings.Value.TargetMod;
            var candidateMasterKey = Settings.Value.CandidateMaster;

            var targetPlugin = state.LoadOrder.FirstOrDefault(x => x.Key.Equals(targetModKey))?.Value?.Mod;
            if (targetPlugin == null)
            {
                Console.WriteLine($"Wherefore doth the user not have {targetModKey.FileName} in their load order?");
                return;
            }

            var candidateMasterPlugin =
                state.LoadOrder.FirstOrDefault(x => x.Key.Equals(candidateMasterKey))?.Value?.Mod;
            if (candidateMasterPlugin == null)
            {
                // User had a typo in their original code (targetModKey instead of candidateMasterKey)
                Console.WriteLine(
                    $"Wherefore doth the user not have {candidateMasterKey.FileName} in their load order?");
                return;
            }

            var listedMasters = targetPlugin.ModHeader.MasterReferences.Select(x => x.Master).ToList();
            if (!listedMasters.Contains(candidateMasterKey))
            {
                Console.WriteLine(
                    $"Masters listed for {targetModKey.FileName} do not contain {candidateMasterKey.FileName}. User may be a dolt. Continuing anyway.");
            }
            else
            {
                Console.WriteLine($"Masters listed for {targetModKey.FileName}:");
                Console.WriteLine($"{string.Join((Environment.NewLine + "\t"), listedMasters)}");
            }

            var recordsToSearch = targetPlugin.EnumerateMajorRecords();

            // Using a HashSet provides much faster lookups (O(1) vs O(n) for a List)
            var newFormKeysInMaster =
                new HashSet<FormKey>(candidateMasterPlugin.EnumerateMajorRecords()
                    .Select(x => x.FormKey)
                    .Where(x => x.ModKey.Equals(candidateMasterKey))
                );

            Console.WriteLine(
                $"Beginning search of {targetModKey.FileName} for references to {candidateMasterKey.FileName}...");

            // This loop now simply calls our recursive function for each top-level record.
            foreach (var record in recordsToSearch)
            {
                var recordLogString = GetLogString(record, true);

                // Start the recursive search on the current record.
                FindMasterReferences(record, new List<string>(), newFormKeysInMaster, state, recordLogString,
                    new HashSet<object>());
            }

            Console.WriteLine("Search complete.");
        }

        public static string GetLogString(IMajorRecordGetter majorRecordGetter, bool fullString = false)
        {
            if (majorRecordGetter.EditorID != null)
            {
                if (fullString)
                {
                    return majorRecordGetter.EditorID + " | " + majorRecordGetter.FormKey.ToString();
                }
                else
                {
                    return majorRecordGetter.EditorID;
                }
            }
            else
            {
                return majorRecordGetter.FormKey.ToString();
            }
        }

        // <summary>
        /// Recursively searches through an object's properties to find FormLinks that point to a master plugin.
        /// </summary>
        /// <param name="currentObject">The object to search within.</param>
        /// <param name="currentPath">The list of property names traversed to reach this object.</param>
        /// <param name="masterFormKeys">A HashSet of all FormKeys from the candidate master for fast lookups.</param>
        /// <param name="state">The patcher state, used for resolving links for logging.</param>
        /// <param name="rootRecordLogString">The string identifier of the top-level record being searched.</param>
        /// <param name="visitedObjects">A set of visited object references to prevent infinite loops from cyclical references.</param>
        private static void FindMasterReferences(
            object? currentObject,
            List<string> currentPath,
            HashSet<FormKey> masterFormKeys,
            IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
            string rootRecordLogString,
            HashSet<object> visitedObjects)
        {
            // --- Pre-check and Cycle Prevention ---
            if (currentObject == null) return;

            // For reference types, adding to the HashSet prevents infinite recursion. This is crucial.
            // For value types, this check is less effective but harmless.
            if (currentObject is not ValueType && !visitedObjects.Add(currentObject)) return;

            var type = currentObject.GetType();

            // We don't need to reflect into primitives, enums, or strings.
            if (type.IsPrimitive || type.IsEnum || type == typeof(string)) return;

            // --- Base Case: Found a FormLink ---
            if (currentObject is IFormLinkGetter formLink)
            {
                if (!formLink.IsNull && masterFormKeys.Contains(formLink.FormKey))
                {
                    var pathString = string.Join(" -> ", currentPath);
                    var targetRecordString = GetLogStringForLink(formLink, state);
                    Console.WriteLine($"{rootRecordLogString} -> {pathString} -> {targetRecordString}");
                }

                // Per your request, stop searching this branch once a link is found.
                return;
            }

            // --- Recursive Step 1: Collections ---
            if (currentObject is System.Collections.IEnumerable collection && currentObject is not string)
            {
                int i = 0;
                foreach (var item in collection)
                {
                    // We create a new path list for each item in the collection
                    var newPath = new List<string>(currentPath);
                    if (newPath.Any())
                    {
                        // Append the index to the last property name, e.g., "Keywords" becomes "Keywords[0]"
                        newPath[^1] = $"{newPath.Last()}[{i++}]";
                        FindMasterReferences(item, newPath, masterFormKeys, state, rootRecordLogString, visitedObjects);
                    }
                }

                return; // After handling a collection's items, we don't need to check the collection's own properties.
            }

            // --- Recursive Step 2: Complex Objects ---
            // To avoid reflecting over the entire .NET framework, we'll focus on types from Mutagen.
            if (type.Namespace == null || !type.Namespace.StartsWith("Mutagen")) return;

            // Get all public properties of the object
            foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                // Skip indexers (like 'this[]') and properties that aren't useful for this search.
                if (property.GetIndexParameters().Length > 0) continue;
                if (property.Name is "FormKey" or "EditorID" or "Master" or "VersionControl" or "Version2") continue;

                object? propertyValue;
                try
                {
                    propertyValue = property.GetValue(currentObject);
                }
                catch
                {
                    continue; // Skip properties that throw exceptions on access
                }

                // Create the path for the next level of recursion
                var newPath = new List<string>(currentPath) { property.Name };
                FindMasterReferences(propertyValue, newPath, masterFormKeys, state, rootRecordLogString,
                    visitedObjects);
            }
        }

        /// <summary>
        /// Helper method to get a readable string for a FormLink, resolving it if possible.
        /// </summary>
        private static string GetLogStringForLink(IFormLinkGetter link,
            IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (state.LinkCache.TryResolve(link, out var resolved) && resolved != null)
            {
                return GetLogString(resolved, true); // Use your existing helper
            }

            return link.FormKey.ToString();
        }
    }
}
